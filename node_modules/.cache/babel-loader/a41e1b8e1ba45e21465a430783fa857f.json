{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"/Users/lucmosser/code/lmssr/chat_react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nconst EventEmitter = require('events');\n\nconst urlLib = require('url');\n\nconst normalizeUrl = require('normalize-url');\n\nconst getStream = require('get-stream');\n\nconst CachePolicy = require('http-cache-semantics');\n\nconst Response = require('responselike');\n\nconst lowercaseKeys = require('lowercase-keys');\n\nconst cloneResponse = require('clone-response');\n\nconst Keyv = require('keyv');\n\nclass CacheableRequest {\n  constructor(request, cacheAdapter) {\n    if (typeof request !== 'function') {\n      throw new TypeError('Parameter `request` must be a function');\n    }\n\n    this.cache = new Keyv({\n      uri: typeof cacheAdapter === 'string' && cacheAdapter,\n      store: typeof cacheAdapter !== 'string' && cacheAdapter,\n      namespace: 'cacheable-request'\n    });\n    return this.createCacheableRequest(request);\n  }\n\n  createCacheableRequest(request) {\n    return (opts, cb) => {\n      let url;\n\n      if (typeof opts === 'string') {\n        url = normalizeUrlObject(urlLib.parse(opts));\n        opts = {};\n      } else if (opts instanceof urlLib.URL) {\n        url = normalizeUrlObject(urlLib.parse(opts.toString()));\n        opts = {};\n      } else {\n        const _split = (opts.path || '').split('?'),\n              _split2 = _toArray(_split),\n              pathname = _split2[0],\n              searchParts = _split2.slice(1);\n\n        const search = searchParts.length > 0 ? \"?\".concat(searchParts.join('?')) : '';\n        url = normalizeUrlObject({ ...opts,\n          pathname,\n          search\n        });\n      }\n\n      opts = {\n        headers: {},\n        method: 'GET',\n        cache: true,\n        strictTtl: false,\n        automaticFailover: false,\n        ...opts,\n        ...urlObjectToRequestOptions(url)\n      };\n      opts.headers = lowercaseKeys(opts.headers);\n      const ee = new EventEmitter();\n      const normalizedUrlString = normalizeUrl(urlLib.format(url), {\n        stripWWW: false,\n        removeTrailingSlash: false,\n        stripAuthentication: false\n      });\n      const key = \"\".concat(opts.method, \":\").concat(normalizedUrlString);\n      let revalidate = false;\n      let madeRequest = false;\n\n      const makeRequest = opts => {\n        madeRequest = true;\n        let requestErrored = false;\n        let requestErrorCallback;\n        const requestErrorPromise = new Promise(resolve => {\n          requestErrorCallback = () => {\n            if (!requestErrored) {\n              requestErrored = true;\n              resolve();\n            }\n          };\n        });\n\n        const handler = response => {\n          if (revalidate && !opts.forceRefresh) {\n            response.status = response.statusCode;\n            const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);\n\n            if (!revalidatedPolicy.modified) {\n              const headers = revalidatedPolicy.policy.responseHeaders();\n              response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);\n              response.cachePolicy = revalidatedPolicy.policy;\n              response.fromCache = true;\n            }\n          }\n\n          if (!response.fromCache) {\n            response.cachePolicy = new CachePolicy(opts, response, opts);\n            response.fromCache = false;\n          }\n\n          let clonedResponse;\n\n          if (opts.cache && response.cachePolicy.storable()) {\n            clonedResponse = cloneResponse(response);\n\n            (async () => {\n              try {\n                const bodyPromise = getStream.buffer(response);\n                await Promise.race([requestErrorPromise, new Promise(resolve => response.once('end', resolve))]);\n\n                if (requestErrored) {\n                  return;\n                }\n\n                const body = await bodyPromise;\n                const value = {\n                  cachePolicy: response.cachePolicy.toObject(),\n                  url: response.url,\n                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n                  body\n                };\n                let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n\n                if (opts.maxTtl) {\n                  ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;\n                }\n\n                await this.cache.set(key, value, ttl);\n              } catch (error) {\n                ee.emit('error', new CacheableRequest.CacheError(error));\n              }\n            })();\n          } else if (opts.cache && revalidate) {\n            (async () => {\n              try {\n                await this.cache.delete(key);\n              } catch (error) {\n                ee.emit('error', new CacheableRequest.CacheError(error));\n              }\n            })();\n          }\n\n          ee.emit('response', clonedResponse || response);\n\n          if (typeof cb === 'function') {\n            cb(clonedResponse || response);\n          }\n        };\n\n        try {\n          const req = request(opts, handler);\n          req.once('error', requestErrorCallback);\n          req.once('abort', requestErrorCallback);\n          ee.emit('request', req);\n        } catch (error) {\n          ee.emit('error', new CacheableRequest.RequestError(error));\n        }\n      };\n\n      (async () => {\n        const get = async opts => {\n          await Promise.resolve();\n          const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;\n\n          if (typeof cacheEntry === 'undefined') {\n            return makeRequest(opts);\n          }\n\n          const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\n          if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {\n            const headers = policy.responseHeaders();\n            const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);\n            response.cachePolicy = policy;\n            response.fromCache = true;\n            ee.emit('response', response);\n\n            if (typeof cb === 'function') {\n              cb(response);\n            }\n          } else {\n            revalidate = cacheEntry;\n            opts.headers = policy.revalidationHeaders(opts);\n            makeRequest(opts);\n          }\n        };\n\n        const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));\n\n        this.cache.once('error', errorHandler);\n        ee.on('response', () => this.cache.removeListener('error', errorHandler));\n\n        try {\n          await get(opts);\n        } catch (error) {\n          if (opts.automaticFailover && !madeRequest) {\n            makeRequest(opts);\n          }\n\n          ee.emit('error', new CacheableRequest.CacheError(error));\n        }\n      })();\n\n      return ee;\n    };\n  }\n\n}\n\nfunction urlObjectToRequestOptions(url) {\n  const options = { ...url\n  };\n  options.path = \"\".concat(url.pathname || '/').concat(url.search || '');\n  delete options.pathname;\n  delete options.search;\n  return options;\n}\n\nfunction normalizeUrlObject(url) {\n  // If url was parsed by url.parse or new URL:\n  // - hostname will be set\n  // - host will be hostname[:port]\n  // - port will be set if it was explicit in the parsed string\n  // Otherwise, url was from request options:\n  // - hostname or host may be set\n  // - host shall not have port encoded\n  return {\n    protocol: url.protocol,\n    auth: url.auth,\n    hostname: url.hostname || url.host || 'localhost',\n    port: url.port,\n    pathname: url.pathname,\n    search: url.search\n  };\n}\n\nCacheableRequest.RequestError = class extends Error {\n  constructor(error) {\n    super(error.message);\n    this.name = 'RequestError';\n    Object.assign(this, error);\n  }\n\n};\nCacheableRequest.CacheError = class extends Error {\n  constructor(error) {\n    super(error.message);\n    this.name = 'CacheError';\n    Object.assign(this, error);\n  }\n\n};\nmodule.exports = CacheableRequest;","map":null,"metadata":{},"sourceType":"script"}