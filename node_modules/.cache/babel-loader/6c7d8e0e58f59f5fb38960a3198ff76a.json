{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nclass TimeoutError extends Error {\n  constructor(threshold, event) {\n    super(\"Timeout awaiting '\".concat(event, \"' for \").concat(threshold, \"ms\"));\n    this.name = 'TimeoutError';\n    this.code = 'ETIMEDOUT';\n    this.event = event;\n  }\n\n}\n\nconst reentry = Symbol('reentry');\n\nconst noop = () => {};\n\nmodule.exports = (request, delays, options) => {\n  /* istanbul ignore next: this makes sure timed-out isn't called twice */\n  if (request[reentry]) {\n    return;\n  }\n\n  request[reentry] = true;\n  let stopNewTimeouts = false;\n\n  const addTimeout = (delay, callback, ...args) => {\n    // An error had been thrown before. Going further would result in uncaught errors.\n    // See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051\n    if (stopNewTimeouts) {\n      return noop;\n    } // Event loop order is timers, poll, immediates.\n    // The timed event may emit during the current tick poll phase, so\n    // defer calling the handler until the poll phase completes.\n\n\n    let immediate;\n    const timeout = setTimeout(() => {\n      immediate = setImmediate(callback, delay, ...args);\n      /* istanbul ignore next: added in node v9.7.0 */\n\n      if (immediate.unref) {\n        immediate.unref();\n      }\n    }, delay);\n    /* istanbul ignore next: in order to support electron renderer */\n\n    if (timeout.unref) {\n      timeout.unref();\n    }\n\n    const cancel = () => {\n      clearTimeout(timeout);\n      clearImmediate(immediate);\n    };\n\n    cancelers.push(cancel);\n    return cancel;\n  };\n\n  const host = options.host,\n        hostname = options.hostname;\n\n  const timeoutHandler = (delay, event) => {\n    request.emit('error', new TimeoutError(delay, event));\n    request.once('error', () => {}); // Ignore the `socket hung up` error made by request.abort()\n\n    request.abort();\n  };\n\n  const cancelers = [];\n\n  const cancelTimeouts = () => {\n    stopNewTimeouts = true;\n    cancelers.forEach(cancelTimeout => cancelTimeout());\n  };\n\n  request.once('error', cancelTimeouts);\n  request.once('response', response => {\n    response.once('end', cancelTimeouts);\n  });\n\n  if (delays.request !== undefined) {\n    addTimeout(delays.request, timeoutHandler, 'request');\n  }\n\n  if (delays.socket !== undefined) {\n    const socketTimeoutHandler = () => {\n      timeoutHandler(delays.socket, 'socket');\n    };\n\n    request.setTimeout(delays.socket, socketTimeoutHandler); // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n\n    cancelers.push(() => request.removeListener('timeout', socketTimeoutHandler));\n  }\n\n  if (delays.lookup !== undefined && !request.socketPath && !net.isIP(hostname || host)) {\n    request.once('socket', socket => {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n        socket.once('lookup', cancelTimeout);\n      }\n    });\n  }\n\n  if (delays.connect !== undefined) {\n    request.once('socket', socket => {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n\n        if (request.socketPath || net.isIP(hostname || host)) {\n          socket.once('connect', timeConnect());\n        } else {\n          socket.once('lookup', error => {\n            if (error === null) {\n              socket.once('connect', timeConnect());\n            }\n          });\n        }\n      }\n    });\n  }\n\n  if (delays.secureConnect !== undefined && options.protocol === 'https:') {\n    request.once('socket', socket => {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        socket.once('connect', () => {\n          const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n          socket.once('secureConnect', cancelTimeout);\n        });\n      }\n    });\n  }\n\n  if (delays.send !== undefined) {\n    request.once('socket', socket => {\n      const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n      /* istanbul ignore next: hard to test */\n\n\n      if (socket.connecting) {\n        socket.once('connect', () => {\n          request.once('upload-complete', timeRequest());\n        });\n      } else {\n        request.once('upload-complete', timeRequest());\n      }\n    });\n  }\n\n  if (delays.response !== undefined) {\n    request.once('upload-complete', () => {\n      const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      request.once('response', cancelTimeout);\n    });\n  }\n};\n\nmodule.exports.TimeoutError = TimeoutError;","map":null,"metadata":{},"sourceType":"script"}