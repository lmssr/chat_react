{"ast":null,"code":"'use strict';\n\nconst deferToConnect = require('defer-to-connect');\n\nmodule.exports = request => {\n  const timings = {\n    start: Date.now(),\n    socket: null,\n    lookup: null,\n    connect: null,\n    upload: null,\n    response: null,\n    end: null,\n    error: null,\n    phases: {\n      wait: null,\n      dns: null,\n      tcp: null,\n      request: null,\n      firstByte: null,\n      download: null,\n      total: null\n    }\n  };\n\n  const handleError = origin => {\n    const emit = origin.emit.bind(origin);\n\n    origin.emit = (event, ...args) => {\n      // Catches the `error` event\n      if (event === 'error') {\n        timings.error = Date.now();\n        timings.phases.total = timings.error - timings.start;\n        origin.emit = emit;\n      } // Saves the original behavior\n\n\n      return emit(event, ...args);\n    };\n  };\n\n  let uploadFinished = false;\n\n  const onUpload = () => {\n    timings.upload = Date.now();\n    timings.phases.request = timings.upload - timings.connect;\n  };\n\n  handleError(request);\n  request.once('socket', socket => {\n    timings.socket = Date.now();\n    timings.phases.wait = timings.socket - timings.start;\n\n    const lookupListener = () => {\n      timings.lookup = Date.now();\n      timings.phases.dns = timings.lookup - timings.socket;\n    };\n\n    socket.once('lookup', lookupListener);\n    deferToConnect(socket, () => {\n      timings.connect = Date.now();\n\n      if (timings.lookup === null) {\n        socket.removeListener('lookup', lookupListener);\n        timings.lookup = timings.connect;\n        timings.phases.dns = timings.lookup - timings.socket;\n      }\n\n      timings.phases.tcp = timings.connect - timings.lookup;\n\n      if (uploadFinished && !timings.upload) {\n        onUpload();\n      }\n    });\n  });\n  request.once('finish', () => {\n    uploadFinished = true;\n\n    if (timings.connect) {\n      onUpload();\n    }\n  });\n  request.once('response', response => {\n    timings.response = Date.now();\n    timings.phases.firstByte = timings.response - timings.upload;\n    handleError(response);\n    response.once('end', () => {\n      timings.end = Date.now();\n      timings.phases.download = timings.end - timings.response;\n      timings.phases.total = timings.end - timings.start;\n    });\n  });\n  return timings;\n};","map":null,"metadata":{},"sourceType":"script"}