{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/lucmosser/code/lmssr/chat_react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst _require = require('stream'),\n      PassThrough = _require.PassThrough;\n\nconst duplexer3 = require('duplexer3');\n\nconst requestAsEventEmitter = require('./request-as-event-emitter');\n\nconst _require2 = require('./errors'),\n      HTTPError = _require2.HTTPError,\n      ReadError = _require2.ReadError;\n\nmodule.exports = options => {\n  const input = new PassThrough();\n  const output = new PassThrough();\n  const proxy = duplexer3(input, output);\n  const piped = new Set();\n  let isFinished = false;\n\n  options.retry.retries = () => 0;\n\n  if (options.body) {\n    proxy.write = () => {\n      throw new Error('Got\\'s stream is not writable when the `body` option is used');\n    };\n  }\n\n  const emitter = requestAsEventEmitter(options, input); // Cancels the request\n\n  proxy._destroy = emitter.abort;\n  emitter.on('response', response => {\n    const statusCode = response.statusCode;\n    response.on('error', error => {\n      proxy.emit('error', new ReadError(error, options));\n    });\n\n    if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n      proxy.emit('error', new HTTPError(response, options), null, response);\n      return;\n    }\n\n    isFinished = true;\n    response.pipe(output);\n\n    for (const destination of piped) {\n      if (destination.headersSent) {\n        continue;\n      }\n\n      for (const _ref of Object.entries(response.headers)) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const key = _ref2[0];\n        const value = _ref2[1];\n        // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n        // It's not possible to decompress already decompressed data, is it?\n        const allowed = options.decompress ? key !== 'content-encoding' : true;\n\n        if (allowed) {\n          destination.setHeader(key, value);\n        }\n      }\n\n      destination.statusCode = response.statusCode;\n    }\n\n    proxy.emit('response', response);\n  });\n  ['error', 'request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n  const pipe = proxy.pipe.bind(proxy);\n  const unpipe = proxy.unpipe.bind(proxy);\n\n  proxy.pipe = (destination, options) => {\n    if (isFinished) {\n      throw new Error('Failed to pipe. The response has been emitted already.');\n    }\n\n    const result = pipe(destination, options);\n\n    if (Reflect.has(destination, 'setHeader')) {\n      piped.add(destination);\n    }\n\n    return result;\n  };\n\n  proxy.unpipe = stream => {\n    piped.delete(stream);\n    return unpipe(stream);\n  };\n\n  return proxy;\n};","map":null,"metadata":{},"sourceType":"script"}