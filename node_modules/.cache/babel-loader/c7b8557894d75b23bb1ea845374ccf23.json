{"ast":null,"code":"'use strict';\n\nconst _require = require('url'),\n      URL = _require.URL; // TODO: Use the `URL` global when targeting Node.js 10\n\n\nconst util = require('util');\n\nconst EventEmitter = require('events');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst urlLib = require('url');\n\nconst CacheableRequest = require('cacheable-request');\n\nconst toReadableStream = require('to-readable-stream');\n\nconst is = require('@sindresorhus/is');\n\nconst timer = require('@szmarczak/http-timer');\n\nconst timedOut = require('./utils/timed-out');\n\nconst getBodySize = require('./utils/get-body-size');\n\nconst getResponse = require('./get-response');\n\nconst progress = require('./progress');\n\nconst _require2 = require('./errors'),\n      CacheError = _require2.CacheError,\n      UnsupportedProtocolError = _require2.UnsupportedProtocolError,\n      MaxRedirectsError = _require2.MaxRedirectsError,\n      RequestError = _require2.RequestError,\n      TimeoutError = _require2.TimeoutError;\n\nconst urlToOptions = require('./utils/url-to-options');\n\nconst getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);\nconst allMethodRedirectCodes = new Set([300, 303, 307, 308]);\n\nmodule.exports = (options, input) => {\n  const emitter = new EventEmitter();\n  const redirects = [];\n  let currentRequest;\n  let requestUrl;\n  let redirectString;\n  let uploadBodySize;\n  let retryCount = 0;\n  let shouldAbort = false;\n  const setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;\n  const getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;\n  const agents = is.object(options.agent) ? options.agent : null;\n\n  const emitError = async error => {\n    try {\n      for (const hook of options.hooks.beforeError) {\n        // eslint-disable-next-line no-await-in-loop\n        error = await hook(error);\n      }\n\n      emitter.emit('error', error);\n    } catch (error2) {\n      emitter.emit('error', error2);\n    }\n  };\n\n  const get = async options => {\n    const currentUrl = redirectString || requestUrl;\n\n    if (options.protocol !== 'http:' && options.protocol !== 'https:') {\n      throw new UnsupportedProtocolError(options);\n    }\n\n    decodeURI(currentUrl);\n    let fn;\n\n    if (is.function(options.request)) {\n      fn = {\n        request: options.request\n      };\n    } else {\n      fn = options.protocol === 'https:' ? https : http;\n    }\n\n    if (agents) {\n      const protocolName = options.protocol === 'https:' ? 'https' : 'http';\n      options.agent = agents[protocolName] || options.agent;\n    }\n    /* istanbul ignore next: electron.net is broken */\n\n\n    if (options.useElectronNet && process.versions.electron) {\n      const r = {\n        x: require\n      }['yx'.slice(1)]; // Trick webpack\n\n      const electron = r('electron');\n      fn = electron.net || electron.remote.net;\n    }\n\n    if (options.cookieJar) {\n      const cookieString = await getCookieString(currentUrl, {});\n\n      if (is.nonEmptyString(cookieString)) {\n        options.headers.cookie = cookieString;\n      }\n    }\n\n    let timings;\n\n    const handleResponse = async response => {\n      try {\n        /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n        if (options.useElectronNet) {\n          response = new Proxy(response, {\n            get: (target, name) => {\n              if (name === 'trailers' || name === 'rawTrailers') {\n                return [];\n              }\n\n              const value = target[name];\n              return is.function(value) ? value.bind(target) : value;\n            }\n          });\n        }\n\n        const _response = response,\n              statusCode = _response.statusCode;\n        response.url = currentUrl;\n        response.requestUrl = requestUrl;\n        response.retryCount = retryCount;\n        response.timings = timings;\n        response.redirectUrls = redirects;\n        response.request = {\n          gotOptions: options\n        };\n        const rawCookies = response.headers['set-cookie'];\n\n        if (options.cookieJar && rawCookies) {\n          await Promise.all(rawCookies.map(rawCookie => setCookie(rawCookie, response.url)));\n        }\n\n        if (options.followRedirect && 'location' in response.headers) {\n          if (allMethodRedirectCodes.has(statusCode) || getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD')) {\n            response.resume(); // We're being redirected, we don't care about the response.\n\n            if (statusCode === 303) {\n              // Server responded with \"see other\", indicating that the resource exists at another location,\n              // and the client should request it from that location via GET or HEAD.\n              options.method = 'GET';\n            }\n\n            if (redirects.length >= 10) {\n              throw new MaxRedirectsError(statusCode, redirects, options);\n            } // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n\n\n            const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n            const redirectURL = new URL(redirectBuffer, currentUrl);\n            redirectString = redirectURL.toString();\n            redirects.push(redirectString);\n            const redirectOptions = { ...options,\n              ...urlToOptions(redirectURL)\n            };\n\n            for (const hook of options.hooks.beforeRedirect) {\n              // eslint-disable-next-line no-await-in-loop\n              await hook(redirectOptions);\n            }\n\n            emitter.emit('redirect', response, redirectOptions);\n            await get(redirectOptions);\n            return;\n          }\n        }\n\n        getResponse(response, options, emitter);\n      } catch (error) {\n        emitError(error);\n      }\n    };\n\n    const handleRequest = request => {\n      if (shouldAbort) {\n        request.once('error', () => {});\n        request.abort();\n        return;\n      }\n\n      currentRequest = request;\n      request.once('error', error => {\n        if (request.aborted) {\n          return;\n        }\n\n        if (error instanceof timedOut.TimeoutError) {\n          error = new TimeoutError(error, options);\n        } else {\n          error = new RequestError(error, options);\n        }\n\n        if (emitter.retry(error) === false) {\n          emitError(error);\n        }\n      });\n      timings = timer(request);\n      progress.upload(request, emitter, uploadBodySize);\n\n      if (options.gotTimeout) {\n        timedOut(request, options.gotTimeout, options);\n      }\n\n      emitter.emit('request', request);\n\n      const uploadComplete = () => {\n        request.emit('upload-complete');\n      };\n\n      try {\n        if (is.nodeStream(options.body)) {\n          options.body.once('end', uploadComplete);\n          options.body.pipe(request);\n          options.body = undefined;\n        } else if (options.body) {\n          request.end(options.body, uploadComplete);\n        } else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) {\n          input.once('end', uploadComplete);\n          input.pipe(request);\n        } else {\n          request.end(uploadComplete);\n        }\n      } catch (error) {\n        emitError(new RequestError(error, options));\n      }\n    };\n\n    if (options.cache) {\n      const cacheableRequest = new CacheableRequest(fn.request, options.cache);\n      const cacheRequest = cacheableRequest(options, handleResponse);\n      cacheRequest.once('error', error => {\n        if (error instanceof CacheableRequest.RequestError) {\n          emitError(new RequestError(error, options));\n        } else {\n          emitError(new CacheError(error, options));\n        }\n      });\n      cacheRequest.once('request', handleRequest);\n    } else {\n      // Catches errors thrown by calling fn.request(...)\n      try {\n        handleRequest(fn.request(options, handleResponse));\n      } catch (error) {\n        emitError(new RequestError(error, options));\n      }\n    }\n  };\n\n  emitter.retry = error => {\n    let backoff;\n\n    try {\n      backoff = options.retry.retries(++retryCount, error);\n    } catch (error2) {\n      emitError(error2);\n      return;\n    }\n\n    if (backoff) {\n      const retry = async options => {\n        try {\n          for (const hook of options.hooks.beforeRetry) {\n            // eslint-disable-next-line no-await-in-loop\n            await hook(options, error, retryCount);\n          }\n\n          await get(options);\n        } catch (error) {\n          emitError(error);\n        }\n      };\n\n      setTimeout(retry, backoff, { ...options,\n        forceRefresh: true\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  emitter.abort = () => {\n    if (currentRequest) {\n      currentRequest.once('error', () => {});\n      currentRequest.abort();\n    } else {\n      shouldAbort = true;\n    }\n  };\n\n  setImmediate(async () => {\n    try {\n      // Convert buffer to stream to receive upload progress events (#322)\n      const body = options.body;\n\n      if (is.buffer(body)) {\n        options.body = toReadableStream(body);\n        uploadBodySize = body.length;\n      } else {\n        uploadBodySize = await getBodySize(options);\n      }\n\n      if (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) {\n        if ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) {\n          options.headers['content-length'] = uploadBodySize;\n        }\n      }\n\n      for (const hook of options.hooks.beforeRequest) {\n        // eslint-disable-next-line no-await-in-loop\n        await hook(options);\n      }\n\n      requestUrl = options.href || new URL(options.path, urlLib.format(options)).toString();\n      await get(options);\n    } catch (error) {\n      emitError(error);\n    }\n  });\n  return emitter;\n};","map":null,"metadata":{},"sourceType":"script"}