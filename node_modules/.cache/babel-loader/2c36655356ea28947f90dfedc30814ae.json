{"ast":null,"code":"'use strict';\n\nconst urlLib = require('url');\n\nconst http = require('http');\n\nconst PCancelable = require('p-cancelable');\n\nconst is = require('@sindresorhus/is');\n\nclass GotError extends Error {\n  constructor(message, error, options) {\n    super(message);\n    Error.captureStackTrace(this, this.constructor);\n    this.name = 'GotError';\n\n    if (!is.undefined(error.code)) {\n      this.code = error.code;\n    }\n\n    Object.assign(this, {\n      host: options.host,\n      hostname: options.hostname,\n      method: options.method,\n      path: options.path,\n      socketPath: options.socketPath,\n      protocol: options.protocol,\n      url: options.href,\n      gotOptions: options\n    });\n  }\n\n}\n\nmodule.exports.GotError = GotError;\nmodule.exports.CacheError = class extends GotError {\n  constructor(error, options) {\n    super(error.message, error, options);\n    this.name = 'CacheError';\n  }\n\n};\nmodule.exports.RequestError = class extends GotError {\n  constructor(error, options) {\n    super(error.message, error, options);\n    this.name = 'RequestError';\n  }\n\n};\nmodule.exports.ReadError = class extends GotError {\n  constructor(error, options) {\n    super(error.message, error, options);\n    this.name = 'ReadError';\n  }\n\n};\nmodule.exports.ParseError = class extends GotError {\n  constructor(error, statusCode, options, data) {\n    super(\"\".concat(error.message, \" in \\\"\").concat(urlLib.format(options), \"\\\": \\n\").concat(data.slice(0, 77), \"...\"), error, options);\n    this.name = 'ParseError';\n    this.statusCode = statusCode;\n    this.statusMessage = http.STATUS_CODES[this.statusCode];\n  }\n\n};\nmodule.exports.HTTPError = class extends GotError {\n  constructor(response, options) {\n    const statusCode = response.statusCode;\n    let statusMessage = response.statusMessage;\n\n    if (statusMessage) {\n      statusMessage = statusMessage.replace(/\\r?\\n/g, ' ').trim();\n    } else {\n      statusMessage = http.STATUS_CODES[statusCode];\n    }\n\n    super(\"Response code \".concat(statusCode, \" (\").concat(statusMessage, \")\"), {}, options);\n    this.name = 'HTTPError';\n    this.statusCode = statusCode;\n    this.statusMessage = statusMessage;\n    this.headers = response.headers;\n    this.body = response.body;\n  }\n\n};\nmodule.exports.MaxRedirectsError = class extends GotError {\n  constructor(statusCode, redirectUrls, options) {\n    super('Redirected 10 times. Aborting.', {}, options);\n    this.name = 'MaxRedirectsError';\n    this.statusCode = statusCode;\n    this.statusMessage = http.STATUS_CODES[this.statusCode];\n    this.redirectUrls = redirectUrls;\n  }\n\n};\nmodule.exports.UnsupportedProtocolError = class extends GotError {\n  constructor(options) {\n    super(\"Unsupported protocol \\\"\".concat(options.protocol, \"\\\"\"), {}, options);\n    this.name = 'UnsupportedProtocolError';\n  }\n\n};\nmodule.exports.TimeoutError = class extends GotError {\n  constructor(error, options) {\n    super(error.message, {\n      code: 'ETIMEDOUT'\n    }, options);\n    this.name = 'TimeoutError';\n    this.event = error.event;\n  }\n\n};\nmodule.exports.CancelError = PCancelable.CancelError;","map":null,"metadata":{},"sourceType":"script"}