{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/lucmosser/code/lmssr/chat_react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst EventEmitter = require('events');\n\nconst getStream = require('get-stream');\n\nconst is = require('@sindresorhus/is');\n\nconst PCancelable = require('p-cancelable');\n\nconst requestAsEventEmitter = require('./request-as-event-emitter');\n\nconst _require = require('./errors'),\n      HTTPError = _require.HTTPError,\n      ParseError = _require.ParseError,\n      ReadError = _require.ReadError;\n\nconst _require2 = require('./merge'),\n      mergeOptions = _require2.options;\n\nconst _require3 = require('./normalize-arguments'),\n      reNormalize = _require3.reNormalize;\n\nconst asPromise = options => {\n  const proxy = new EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    const emitter = requestAsEventEmitter(options);\n    onCancel(emitter.abort);\n    emitter.on('response', async response => {\n      proxy.emit('response', response);\n      const stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n      let data;\n\n      try {\n        data = await stream;\n      } catch (error) {\n        reject(new ReadError(error, options));\n        return;\n      }\n\n      const limitStatusCode = options.followRedirect ? 299 : 399;\n      response.body = data;\n\n      try {\n        for (const _ref of Object.entries(options.hooks.afterResponse)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          const index = _ref2[0];\n          const hook = _ref2[1];\n          // eslint-disable-next-line no-await-in-loop\n          response = await hook(response, updatedOptions => {\n            updatedOptions = reNormalize(mergeOptions(options, { ...updatedOptions,\n              retry: 0,\n              throwHttpErrors: false\n            })); // Remove any further hooks for that request, because we we'll call them anyway.\n            // The loop continues. We don't want duplicates (asPromise recursion).\n\n            updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n            return asPromise(updatedOptions);\n          });\n        }\n      } catch (error) {\n        reject(error);\n        return;\n      }\n\n      const _response = response,\n            statusCode = _response.statusCode;\n\n      if (options.json && response.body) {\n        try {\n          response.body = JSON.parse(response.body);\n        } catch (error) {\n          if (statusCode >= 200 && statusCode < 300) {\n            const parseError = new ParseError(error, statusCode, options, data);\n            Object.defineProperty(parseError, 'response', {\n              value: response\n            });\n            reject(parseError);\n            return;\n          }\n        }\n      }\n\n      if (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {\n        const error = new HTTPError(response, options);\n        Object.defineProperty(error, 'response', {\n          value: response\n        });\n\n        if (emitter.retry(error) === false) {\n          if (options.throwHttpErrors) {\n            reject(error);\n            return;\n          }\n\n          resolve(response);\n        }\n\n        return;\n      }\n\n      resolve(response);\n    });\n    emitter.once('error', reject);\n    ['request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n  });\n\n  promise.on = (name, fn) => {\n    proxy.on(name, fn);\n    return promise;\n  };\n\n  return promise;\n};\n\nmodule.exports = asPromise;","map":null,"metadata":{},"sourceType":"script"}